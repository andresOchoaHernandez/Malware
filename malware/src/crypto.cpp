#include <crypto.hpp>

#define BUFFER_LEN 2048

cryptography::cryptography()
{
    keyPair = EVP_RSA_gen(2048);

    if(keyPair == nullptr)
    {
        throw "[CRYPTO] Could not create RSA keypar\n";
    }

    FILE* publicKey;

    fopen_s(&publicKey, "publicKey.txt", "rw");

    if(publicKey != nullptr)
    {
        PEM_write_PUBKEY(publicKey,keyPair);
        fclose(publicKey);
    }
    else
    {
        throw "[CRYPTO] Error creating public key file";
    }

    std::ifstream readFile("publicKey.txt");
    std::stringstream buffer;
    buffer << readFile.rdbuf();

    publicKeyPEM = buffer.str();
}

std::string cryptography::encrypt(const std::string& message)
{
    std::string result;

    /* CREATE & INITIALIZE CONTEXT*/
    EVP_PKEY_CTX*ctx=EVP_PKEY_CTX_new(keyPair,nullptr);
    EVP_PKEY_encrypt_init(ctx);

    /* ENCRYPTION */

    /* PREPARE INPUT */
    unsigned char *in = new unsigned char[message.length()];
    std::copy(message.begin(),message.end(),in);
    in[message.length()] = 0;

    size_t outputLen;
    unsigned char *output = new unsigned char[BUFFER_LEN];

    int success = EVP_PKEY_encrypt(ctx,output,&outputLen,in,message.length());
    if(success <= 0)
    {
        throw "[CRYPTO] Could not encrypt the message\n";
    }

    /* TRANSFORM OUTPUT TO STRING */
    for(size_t i = 0; i < outputLen ; i++)
    {
        result.push_back(output[i]);
    }

    delete[] in;
    delete[] output;

    EVP_PKEY_CTX_free(ctx);

    return result;
}

std::string cryptography::decrypt(const std::string& cyphertext)
{
    std::string message;

    /* CREATE & INITIALIZE CONTEXT*/
    EVP_PKEY_CTX*ctx=EVP_PKEY_CTX_new(keyPair,nullptr);
    EVP_PKEY_decrypt_init(ctx);

    /* PREPARE INPUT */
    unsigned char *in = new unsigned char[cyphertext.length()];
    std::copy(cyphertext.begin(),cyphertext.end(),in);
    in[cyphertext.length()] = 0;

    size_t outputLen;
    unsigned char *output = new unsigned char[BUFFER_LEN];

    int success = EVP_PKEY_decrypt(ctx,output,&outputLen,in,cyphertext.length());
    if(success <= 0)
    {
        throw "[CRYPTO] Could not decrypt the message\n";
    }

    /* TRANSFORM OUTPUT TO STRING */
    for(size_t i = 0; i < outputLen ; i++)
    {
        message.push_back(output[i]);
    }

    delete[] in;
    delete[] output;

    EVP_PKEY_CTX_free(ctx);

    return message;
}

std::string cryptography::getPublicKeyPEM()
{
    return publicKeyPEM;
}

cryptography::~cryptography()
{
    EVP_PKEY_free(keyPair);
}